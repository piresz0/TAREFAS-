1- Crie um algoritmo que tenha vari√°veis que representam disciplinas. Exemplo: Ci√™ncias, Matem√°ticas,
Portugu√™s, Educa√ß√£o F√≠sica, Geografia, Hist√≥ria, etc.
Cada disciplina ter√° n√∫meros de ponto flutuante como chave, e o nome dos alunos como valor dessas
chaves. Exemplo, Pedrinho tirou 5,2 em Matem√°tica -> val matem√°tica = mapOf(5,2 to ‚ÄúPedrinho‚Äù).
Depois imprima todos os alunos aprovados, aqueles que tiraram mais do que 6, no final do c√≥digo.


fun main() {

    val ciencias = mapOf("Joao" to 10.0,"Maria" to 9.6,"Ana" to 5.5)

    val matematica = mapOf("Joao" to 8.3, "Maria" to 4.5, "Ana" to 8.7)

    print ("Notas de Ci√™ncias Aprovados\n")
    ciencias.filter { it.value > 6.0 }
        .forEach { (aluno, nota) -> println("$aluno = $nota") }
    
    
}

============================================================================================================================================================================================================================


2- Uma equipe de jogadores de LoL querem armazenar dados de suas partidas para analisar com mais
cuidados tudo o que aconteceu durante cada partida. Crie um algoritmo capaz de armazenar em mapa
as seguintes caracter√≠sticas:
- Dano Total,
- Dano M√©dio,
- Dano Sofrido M√©dio.
- Dist√¢ncia Percorrida,

- N√∫mero de Mortes (derrota),
- N√∫mero de Abatimento (inimigos mortos).
Considerando que a equipe tenha 4 jogadores, separe a informa√ß√£o de cada jogador em um mapa.
Depois imprima a m√©dia da equipe de cada uma das chaves que foram citadas acima.

https://pl.kotl.in/-NhHbJF_-

data class Estatisticas(
	val danoTotal: Int,
    val danoMedio: Int,
    val danoSofridoMedio: Int,
    val distanciaPercorrida: Int,
    val numeroDeMortes: Int,
    val numeroDeAbates: Int

)

fun main() {
    
    		val equipe = mutableMapOf<String, Estatisticas>()
            
            println("Quantos jogadores deseja cadastrar? ")
            val numJogadores = readLine()!!.toInt()
            
            for (i in 1..numJogadores){
                println("Digite o nome do Jogador $i: ")
                val nome = readLine()!!
                
                println("danoTotal: ")
                val danoTotal = readLine()!!.toInt()
                
                println("danoMedio: ")
                val danoMedio = readLine()!!.toInt()
                
                println("danoSofridoMedio: ")
                val danoSofridoMedio = readLine()!!.toInt()
                
                println("distanciaPercorrida: ")
                val distanciaPercorrida = readLine()!!.toInt()
                
                println("numeroDeMortes: ")
                val numeroDeMortes = readLine()!!.toInt()
                
                println("numeroDeAbates: ")
                val numeroDeAbates = readLine()!!.toInt()
                
                equipe[nome] = Estatisticas(
                	danoTotal, danoMedio, danoSofridoMedio,
                    distanciaPercorrida, numeroDeMortes, numeroDeAbates
                )
                println("---------")
                
            }
     
     var totalDanoTotal = 0
     var totalDanoMedio = 0
     var totalDanoSofrido = 0
     var totalDistancia = 0
     var totalMortes = 0
     var totalAbates = 0
     
   
        
        equipe.forEach {(_, stats) ->
            totalDanoTotal += stats.danoTotal
            totalDanoMedio += stats.danoMedio
            totalDanoSofrido += stats.danoSofridoMedio
            totalDistancia += stats.distanciaPercorrida
            totalMortes += stats.numeroDeMortes
            totalAbates += stats.numeroDeAbates
           }
        
        
        val numeroJogadores = equipe.size
    	
		println("M√©dia da equipe:")
        println("Dano Total: ${totalDanoTotal / numeroJogadores}")
        println("Dano M√©dio: ${totalDanoMedio / numeroJogadores}")
        println("Dano M√©dio Sofrido: ${totalDanoSofrido / numeroJogadores}")
        println("Distancia M√©dia: ${totalDistancia / numeroJogadores}")
        println("M√©dia Mortes: ${totalMortes / numeroJogadores}")
        println("M√©dia Abates: ${totalAbates / numeroJogadores}")
    	
        }

============================================================================================================================================================================================================================


3- Uma comiss√£o desportiva quer que voc√™ crie um programa para armazenar dados de um torneio de
futebol, esses dados s√£o: gols marcados, gols sofridos, descri√ß√£o do gol (nome do jogador, tempo que
o gol aconteceu, como foi o gol: normal, falta, p√™nalti, etc.), faltas cometidas (nome do jogador que
sofreu e cometeu a falta, teve cart√£o? Teve les√£o?), tempo da partida, jogadores titulares, jogadores
reserva, jogadores substitu√≠dos tanto os que sa√≠ram como os que entraram, nome dos √°rbitros, n√∫mero
de laterais cobrados, n√∫mero de escanteio cobrados. Fa√ßa com que o algoritmo armazena os dados dos
dois times que jogaram a partida.
Simule 5 partidas, depois disso imprima, quem foi o time que marcou mais gols, quem foi o time que
cometeu mais faltas, quem foi o jogador que mais marcou gols, quem foi o jogador mais substitu√≠do (que
saiu de campo), qual time sofreu mais gols, qual o tipo de gol mais comum, qual o jogador que mais
cometeu faltas, n√∫mero de cart√µes amarelos e vermelhos durante o campeonato, nome do jogadores
lesionados, qual time titular marcou mais gols sem sofrer nenhum gol, qual jogador reserva entrou mais
vezes em campo, qual time mais tocou a bola para fora (lateral e escanteio), e por fim a posi√ß√£o de cada
time no campeonato, do primeiro ao √∫ltimo lugar.
Use somente mapas nesse exerc√≠cio, n√£o use listas e nem classes.

https://pl.kotl.in/-hTOd30w4


fun main() {
    val times = mutableMapOf<String, MutableMap<String, Any>>()

    // Criando 2 times
    val timeA = "Tigres"
    val timeB = "Le√µes"

    times[timeA] = mutableMapOf(
        "golsMarcados" to 0,
        "golsSofridos" to 0,
        "faltasCometidas" to 0,
        "escanteios" to 0,
        "laterais" to 0,
        "jogadores" to mutableMapOf<String, MutableMap<String, Any>>()
    )

    times[timeB] = mutableMapOf(
        "golsMarcados" to 0,
        "golsSofridos" to 0,
        "faltasCometidas" to 0,
        "escanteios" to 0,
        "laterais" to 0,
        "jogadores" to mutableMapOf<String, MutableMap<String, Any>>()
    )

    // Jogadores (nomes fict√≠cios)
    val jogadoresA = listOf("Jo√£o", "Carlos", "Pedro", "Rafael", "Lucas", "Miguel")
    val jogadoresB = listOf("Henrique", "Matheus", "Tiago", "F√°bio", "Gustavo", "Diego")

    // Inicializa dados dos jogadores
    for (j in jogadoresA) {
        (times[timeA]?.get("jogadores") as MutableMap<String, MutableMap<String, Any>>)[j] =
            mutableMapOf("gols" to 0, "faltas" to 0, "substituido" to 0, "entrou" to 0, "lesao" to false)
    }
    for (j in jogadoresB) {
        (times[timeB]?.get("jogadores") as MutableMap<String, MutableMap<String, Any>>)[j] =
            mutableMapOf("gols" to 0, "faltas" to 0, "substituido" to 0, "entrou" to 0, "lesao" to false)
    }

    val tiposGol = mutableMapOf("normal" to 0, "falta" to 0, "penalti" to 0)

    // Simular 5 partidas
    repeat(5) {
        val golsA = (0..3).random()
        val golsB = (0..3).random()
        val faltasA = (1..5).random()
        val faltasB = (1..5).random()
        val escanteiosA = (1..4).random()
        val escanteiosB = (1..4).random()
        val lateraisA = (2..6).random()
        val lateraisB = (2..6).random()

        // Atualiza dados do time A
        times[timeA]?.set("golsMarcados", (times[timeA]?.get("golsMarcados") as Int) + golsA)
        times[timeA]?.set("golsSofridos", (times[timeA]?.get("golsSofridos") as Int) + golsB)
        times[timeA]?.set("faltasCometidas", (times[timeA]?.get("faltasCometidas") as Int) + faltasA)
        times[timeA]?.set("escanteios", (times[timeA]?.get("escanteios") as Int) + escanteiosA)
        times[timeA]?.set("laterais", (times[timeA]?.get("laterais") as Int) + lateraisA)

        // Atualiza dados do time B
        times[timeB]?.set("golsMarcados", (times[timeB]?.get("golsMarcados") as Int) + golsB)
        times[timeB]?.set("golsSofridos", (times[timeB]?.get("golsSofridos") as Int) + golsA)
        times[timeB]?.set("faltasCometidas", (times[timeB]?.get("faltasCometidas") as Int) + faltasB)
        times[timeB]?.set("escanteios", (times[timeB]?.get("escanteios") as Int) + escanteiosB)
        times[timeB]?.set("laterais", (times[timeB]?.get("laterais") as Int) + lateraisB)

        // Simular gols e faltas de jogadores
        for (i in 1..golsA) {
            val jogador = jogadoresA.random()
            val dados = (times[timeA]?.get("jogadores") as MutableMap<String, MutableMap<String, Any>>)[jogador]
            dados?.set("gols", (dados["gols"] as Int) + 1)
            val tipo = listOf("normal", "falta", "penalti").random()
            tiposGol[tipo] = (tiposGol[tipo] ?: 0) + 1
        }

        for (i in 1..golsB) {
            val jogador = jogadoresB.random()
            val dados = (times[timeB]?.get("jogadores") as MutableMap<String, MutableMap<String, Any>>)[jogador]
            dados?.set("gols", (dados["gols"] as Int) + 1)
            val tipo = listOf("normal", "falta", "penalti").random()
            tiposGol[tipo] = (tiposGol[tipo] ?: 0) + 1
        }
    }

    // An√°lises
    val maisGols = times.maxByOrNull { it.value["golsMarcados"] as Int }?.key
    val maisFaltas = times.maxByOrNull { it.value["faltasCometidas"] as Int }?.key
    val maisSofreu = times.maxByOrNull { it.value["golsSofridos"] as Int }?.key
    val maisEscanteios = times.maxByOrNull { it.value["escanteios"] as Int }?.key

    var jogadorMaisGols = ""
    var maxGols = 0
    for ((time, dados) in times) {
        val jogadores = dados["jogadores"] as Map<String, Map<String, Any>>
        for ((nome, stats) in jogadores) {
            if ((stats["gols"] as Int) > maxGols) {
                maxGols = stats["gols"] as Int
                jogadorMaisGols = nome
            }
        }
    }

    val tipoMaisComum = tiposGol.maxByOrNull { it.value }?.key

    println("üèÜ Time que mais marcou gols: $maisGols")
    println("üü• Time que cometeu mais faltas: $maisFaltas")
    println("‚öΩ Jogador que mais marcou gols: $jogadorMaisGols ($maxGols gols)")
    println("ü•Ö Time que sofreu mais gols: $maisSofreu")
    println("üéØ Tipo de gol mais comum: $tipoMaisComum")
    println("üö© Time que cobrou mais escanteios: $maisEscanteios")
}

============================================================================================================================================================================================================================

Uma usina quer que voc√™ crie um programa que ajude a controlar a energia gerada. Para isso voc√™ deve
criar uma classe que armazena os seguintes dados:
a. Energia gerada;
b. In√≠cio do hor√°rio de funcionamento;
c. T√©rmino do hor√°rio de funcionamento;
d. Supervisor (deve ser outra classe, com nome, turno e especializa√ß√£o);
e. Profissional Respons√°vel (deve ser outra classe, com nome, cargo, turno e supervisor);
f. Tipos de Problemas (se voc√™ desejar, pode criar um ENUM).
Toda vez que acontecer um problema o algoritmo deve gerar um relat√≥rio e armazenar esse mesmo
relat√≥rio em um mapa, as chaves desse mapa deve abordar as seguintes quest√µes:
a. Qual hor√°rio aconteceu o problema;
b. Quem era profissional respons√°vel;
c. Qual foi a natureza (o tipo) do problema;
d. Descri√ß√£o do problema;
e. O problema foi resolvido;
f. Houve impacto na gera√ß√£o de energia? Quanto?
Simule ao menos 5 problemas. Imprima o relat√≥rio na tela, ordenados por hor√°rio e tamb√©m fa√ßa um
filtro de profissional respons√°vel, especificado pelo usu√°rio.

https://pl.kotl.in/jfYut-VcE


import java.time.LocalTime
import java.time.format.DateTimeFormatter
import java.util.TreeMap

// ENUM para tipos de problema
enum class TipoProblema {
    FALHA_ELETRICA,
    SUPERAQUECIMENTO,
    FALHA_MECANICA,
    ERRO_HUMANO,
    CURTO_CIRCUITO
}

// Supervisor
data class Supervisor(val nome: String, val turno: String, val especializacao: String)

// Profissional respons√°vel
data class Profissional(
    val nome: String,
    val cargo: String,
    val turno: String,
    val supervisor: Supervisor
)

// Classe principal da Usina
data class Usina(
    val energiaGerada: Double,
    val inicioFuncionamento: LocalTime,
    val terminoFuncionamento: LocalTime,
    val profissional: Profissional
)

// Relat√≥rio de problemas
data class RelatorioProblema(
    val horario: LocalTime,
    val profissional: Profissional,
    val tipo: TipoProblema,
    val descricao: String,
    val resolvido: Boolean,
    val impactoEnergia: Double
)

fun main() {
    // Criando supervisor e profissionais
    val sup = Supervisor("Carlos Silva", "Noturno", "El√©trica")
    val prof1 = Profissional("Jo√£o Mendes", "Engenheiro", "Noturno", sup)
    val prof2 = Profissional("Ana Souza", "T√©cnica", "Diurno", sup)

    val usina = Usina(energiaGerada = 10000.0,
        inicioFuncionamento = LocalTime.of(6, 0),
        terminoFuncionamento = LocalTime.of(22, 0),
        profissional = prof1
    )

    // Relat√≥rios de problemas (mapa ordenado por hor√°rio)
    val relatorios = TreeMap<LocalTime, RelatorioProblema>()

    // Simulando 5 problemas
    relatorios[LocalTime.of(8, 30)] = RelatorioProblema(
        LocalTime.of(8, 30), prof1, TipoProblema.FALHA_ELETRICA,
        "Queda de energia no setor 3", true, 150.0
    )
    relatorios[LocalTime.of(10, 15)] = RelatorioProblema(
        LocalTime.of(10, 15), prof2, TipoProblema.SUPERAQUECIMENTO,
        "Temperatura acima de 100¬∫C em unidade B", false, 300.0
    )
    relatorios[LocalTime.of(12, 50)] = RelatorioProblema(
        LocalTime.of(12, 50), prof1, TipoProblema.ERRO_HUMANO,
        "Comando incorreto acionou alarme", true, 50.0
    )
    relatorios[LocalTime.of(15, 10)] = RelatorioProblema(
        LocalTime.of(15, 10), prof2, TipoProblema.FALHA_MECANICA,
        "Problema no gerador principal", false, 500.0
    )
    relatorios[LocalTime.of(18, 45)] = RelatorioProblema(
        LocalTime.of(18, 45), prof1, TipoProblema.CURTO_CIRCUITO,
        "Curto-circuito em painel de controle", true, 200.0
    )

    val formatter = DateTimeFormatter.ofPattern("HH:mm")

    // Imprimindo todos os relat√≥rios, ordenados por hor√°rio
    println("üìù RELAT√ìRIOS DE PROBLEMAS (ORDENADOS POR HOR√ÅRIO):\n")
    for ((horario, rel) in relatorios) {
        println("üïí ${horario.format(formatter)}")
        println("üë∑ Profissional: ${rel.profissional.nome}")
        println("‚ö† Tipo: ${rel.tipo}")
        println("üìÑ Descri√ß√£o: ${rel.descricao}")
        println("‚úÖ Resolvido: ${rel.resolvido}")
        println("‚ö° Impacto na energia: ${rel.impactoEnergia} MW\n")
    }

    // Filtro por profissional (usu√°rio informa)
    print("\nüîç Digite o nome do profissional para filtrar os problemas: ")
    val nomeFiltro = readLine()?.trim()

    println("\nüìå RELAT√ìRIOS DE $nomeFiltro:")
    var encontrou = false
    for ((_, rel) in relatorios) {
        if (rel.profissional.nome.equals(nomeFiltro, ignoreCase = true)) {
            encontrou = true
            println("üïí ${rel.horario.format(formatter)} - ${rel.tipo} - ${rel.descricao} - Impacto: ${rel.impactoEnergia} MW")
        }
    }
    if (!encontrou) {
        println("Nenhum relat√≥rio encontrado para este profissional.")
    }
}



Declara√ß√£o de Vari√°veis
kotlin
Copiar
Editar
val nome = "Maria"        // Imut√°vel (como final em Java)
var idade = 25            // Mut√°vel

2. Fun√ß√£o Principal
kotlin
Copiar
Editar
fun main() {
    println("Ol√°, Kotlin!")
}

3. Fun√ß√µes
kotlin
Copiar
Editar
fun saudacao(nome: String): String {
    return "Ol√°, $nome"
}

4. Condicional if/else
kotlin
Copiar
Editar
val nota = 7

if (nota >= 6) {
    println("Aprovado")
} else {
    println("Reprovado")
}

 5. When (switch do Kotlin)
kotlin
Copiar
Editar
val dia = 3

val nomeDoDia = when(dia) {
    1 -> "Domingo"
    2 -> "Segunda"
    3 -> "Ter√ßa"
    else -> "Outro dia"
}

 6. La√ßos de Repeti√ß√£o
kotlin
Copiar
Editar
// For
for (i in 1..5) {
    println(i)
}

// While
var i = 1
while (i <= 5) {
    println(i)
    i++
}

7. Arrays e Listas
kotlin
Copiar
Editar
val numeros = arrayOf(1, 2, 3)
val nomes = listOf("Ana", "Jo√£o", "Pedro")

8. Classes e Objetos
kotlin
Copiar
Editar
class Pessoa(val nome: String, var idade: Int)

fun main() {
    val p = Pessoa("Lucas", 30)
    println(p.nome)
}

9. Null Safety
kotlin
Copiar
Editar
var nome: String? = null

// Safe call
println(nome?.length)

// Elvis operator
val tamanho = nome?.length ?: 0

 10. Fun√ß√µes Lambda
kotlin
Copiar
Editar
val dobrar = { x: Int -> x * 2 }
println(dobrar(4)) // Resultado: 8















Sintaxe B√°sica
kotlin
Copiar
Editar
val mapa = mapOf("chave1" to "valor1", "chave2" to "valor2")
Exemplo:

kotlin
Copiar
Editar
val capitais = mapOf(
    "Brasil" to "Bras√≠lia",
    "Fran√ßa" to "Paris",
    "Jap√£o" to "T√≥quio"
)

Acessando um valor:

kotlin
Copiar
Editar
println(capitais["Brasil"]) // Bras√≠lia


 Iterando sobre um mapOf
kotlin
Copiar
Editar
for ((pais, capital) in capitais) {
    println("A capital de $pais √© $capital")
}


 Verificando se existe uma chave ou valor
kotlin
Copiar
Editar
println("Brasil" in capitais) // true
println(capitais.containsKey("Fran√ßa")) // true
println(capitais.containsValue("Paris")) // true


mapOf √© somente leitura
Se voc√™ quiser um mapa que possa modificar (adicionar, remover, etc.), use mutableMapOf.

kotlin
Copiar
Editar
val mapaMutavel = mutableMapOf("A" to 1)
mapaMutavel["B"] = 2







exemplos de mapof e classe

Claro! Vou te mostrar um exemplo simples de como usar o map com uma classe em JavaScript/TypeScript.

Vamos supor que temos uma classe Pessoa e queremos transformar um array de objetos dessa classe usando map.

javascript
Copiar
Editar
// Definindo a classe Pessoa
class Pessoa {
  constructor(nome, idade) {
    this.nome = nome;
    this.idade = idade;
  }

  apresentar() {
    return `Oi, meu nome √© ${this.nome} e tenho ${this.idade} anos.`;
  }
}

// Criando um array de pessoas
const pessoas = [
  new Pessoa('Jo√£o', 25),
  new Pessoa('Maria', 30),
  new Pessoa('Carlos', 22),
];

// Usando map para criar um array s√≥ com as apresenta√ß√µes
const apresentacoes = pessoas.map(pessoa => pessoa.apresentar());

console.log(apresentacoes);




2 exemplo 


// Defini√ß√£o da classe Produto
class Produto {
  // O construtor recebe nome, pre√ßo e percentual de desconto
  constructor(nome, preco, descontoPercentual) {
    this.nome = nome;                   // nome do produto
    this.preco = preco;                 // pre√ßo original
    this.descontoPercentual = descontoPercentual; // desconto em %
  }

  // M√©todo que calcula o pre√ßo j√° com o desconto aplicado
  precoComDesconto() {
    // Multiplica o pre√ßo original pelo fator (1 - desconto/100)
    return this.preco * (1 - this.descontoPercentual / 100);
  }

  // M√©todo que retorna um objeto formatado com as informa√ß√µes do produto
  infoFormatada() {
    return {
      // Nome em mai√∫sculas para destaque
      nome: this.nome.toUpperCase(),

      // Pre√ßo original formatado como moeda com 2 casas decimais
      precoOriginal: `R$${this.preco.toFixed(2)}`,

      // Pre√ßo final com desconto, tamb√©m formatado
      precoFinal: `R$${this.precoComDesconto().toFixed(2)}`,

      // Percentual do desconto exibido em string
      desconto: `${this.descontoPercentual}%`,
    };
  }
}

// Criando um array com inst√¢ncias da classe Produto
const produtos = [
  new Produto('Camiseta', 50, 10),
  new Produto('Cal√ßa', 120, 20),
  new Produto('T√™nis', 300, 15),
];

// Usando o map para transformar cada Produto em seu formato final
const produtosFormatados = produtos.map(produto => produto.infoFormatada());

// Exibindo o resultado formatado no console
console.log(produtosFormatados);
